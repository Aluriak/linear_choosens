# n choose k problem, and related implementations
Comparison of four Python implementations of the n choose k problem: *Choose randomly n elements in a list of k elements*.
The distribution should be uniform: equiprobability is a necessary condition.

## Implemented methods
The four following methods are implemented. The third one is the main interest of this repository.
Further formal analysis of the method needs to be done.

### stdlib
The `random.sample` method do exactly the job. It automatically choose between two internal implementations,
function to n. [Link to the doc](https://hg.python.org/cpython/file/3.5/Lib/random.py#l280).


### dumb
The very obvious *mix it, then take the n firsts*.
Very costly.


### linear
This is an implementation proposal, that needs to be mathematically proven before any use.
Its less efficient than stdlib when n is small, but notably quicker when n comes near k.

The first element have a `n/k` likelihood to be in the output subset.
If this element is choosen, then find the next choosens is like n-1 choose k-1.
This treatment is recursively applied on the k items.

This method allows an O(1) complexity in memory, and a O(k) complexity in time (worst case),
because elements are walked only once, and deciding whether an element is choosen or not
is a comparison of a random number against a likelihood.
The subset is consequently constructed during the walk of all elements.
Eventually, all the k elements don't need to be walked, when the search is 0 choose k-i.


### (linear) recursive
Purely recursive implementation of the linear algorithm.
Slower, don't work on big dataset without modification of python stack size.


## Runtime comparison
![runtimes](results/runtime_100.png)
The stdlib implementation is better when n is small, but the linear implementation
seems to be quicker in other cases.


## linear method distribution
Following graphics don't show any obvious distribution bias between firsts and lasts elements.
Further analysis of the data could highlight a bias.
A mathematical proof of the approach remain the safest way to (in)validate the approach.

![runtimes](./results/benchmark_l_100_1000_100.png)

![runtimes](./results/benchmark_l_900_1000_100.png)
